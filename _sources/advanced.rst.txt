.. _advanced:

==============================================
Advanced
==============================================
The Py-GraSPI package also offers advanced functionality for developers and users with advanced
technical skills.

User Functionality
==================

Visualize Graphs
~~~~~~~~~~~~~~~~

To visualize graphs, call the visualize(graph_data, is_2D) function.

.. code-block:: python

    # Visualize the graph (2D)
    ig.visualize(graph_data, true)

Filtering Graphs
~~~~~~~~~~~~~~~~
To filter a graph, call the filterGraph(graph_data) function

.. code-block:: python

    # Filter the graph
    fg = ig.filterGraph(graph_data)

Computing Connected Components
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
To compute the connected components of a graph, call the connected_components() function

.. code-block:: python

    # Computing connected components from the filtered graph
    cc_graph = fg.connected_components()
    print(f"Connected Components: {cc_graph}")
    print(f"Number of Connected Components: {len(cc_graph)}")


Running Memory Tests
====================

To run memory tests, run the following command in the terminal:

.. code-block:: bash

    python main.py n dimension function

**Make sure of the following:**

* Replace "n" with the size of the graph you want. **Note:** n should be between 1-1000 for 2D graphs and 1-100 for 3D graphs. Otherwise, the code will timeout.
* Replace "dimension" with 2D or 3D specify if you want a 2D or 3D graph.
* Replace "function" with either generage, filter, or shortest_path to choose which function you want to test memory for.

Example:

.. code-block:: bash

    python main.py 10 2D generate

Testing Algorithms
==================

To **generate graphs**, call the generateGraph(file) function which takes in an input-file name

- Returns a graph (graph_data_class object)
    - g: graph object
    - s_2D: bool of whether the graph is 2D
    - black_vertices: list of all black vertices
    - white_vertices: list of all white vertices
    - black_green: number of edges from black to interface (green vertex)
    - black_interface_red: number of black interface vertices that has a path to top (red)
    - white_interface_blue: number of white interface vertices that has a path to bottom (blue)
    - dim: value of vertices in y direction for 2D and z direction for 3D
    - interface_edge_comp_paths: number of interface edges with complementary paths to top (red) and bottom (blue)
    - shortest_path_to_red: shortest paths from all vertices to red
    - shortest_path_to_blue: shortest paths from all vertices to blue
    - CT_n_D_adj_An: number of black vertices in direct contact with top (red)
    - CT_n_A_adj_Ca: number of white vertices in direct contact with bottom (blue)

.. code-block:: python
    filename = "2D-testFile/testFile-10-2D.txt"
    ig.generateGraph(filename)   # utilizing the test file found in 2D-testFiles folder as an example

To **filter graphs**, call filterGraph(graph) function which takes in a graph object

- Can pass a graph generated by generateGraph(file)
- Returns a filtered graph

.. code-block:: python

    g = ig.generateGraph("2D-testFile/testFile-10-2D.txt")     # utilizing the test file found in 2D-testFiles folder as an example
    fg = ig.filterGraph(g)

- The connected components is the result produced by the connected_components function:

.. code-block:: python

    print(f"Number of Connected Components: {len(fg.connected_components())}")
    print(f"Connected Components: {fg.connected_components()}")

To get a **dictionary of descriptors**, call the descriptors(graph_data, filename) function
It takes in the graph_data_class object returned from generateGraph() and an input filename as the parameters.

.. code-block:: python

    dict = ig.descriptors(graph_data,filename)
    ig.descriptorsToTxt(dict,"descriptors_list.txt")

To test if descriptors are computed correctly, you can run the following script in the terminal to check.
- Make sure you are in the py-graspi directory after git cloning
- Then run the command

.. code-block:: bash

    cd tests
    python descriptor_testing.py ../data/data/data_0.5_2.2_001900.txt

Translating .plt files to .txt files
========================================

These are the steps for translating .plt files to .txt files in order to be turned into graphs.
1. Make sure you cd into the py_graspi directory.
2. All necessary functions are in the plt_to_txt.py file.
3. The command line input format for this file is as follows:

.. code-block:: bash

    python plt_to_txt.py [pathname]

4. The file in pathname should be in the plt directory and end with the .plt extension, if not this will not work.
5. It's translated .plt file should show up in the same directory but now with a .txt extension and in .txt formatting when executed with no errors.
6. Some files have been placed in the .plt directory for testing.
7. If you wish to run an example, first delete the translated version of a .plt file if it has been created, and run the following command line input:

.. code-block:: bash

    python plt_to_txt.py plt/5x4x3.plt

8. Make sure the translated file with .txt extension has been made and placed in the plt directory to ensure the file has been executed correctly.

Translate Image File Into Truncated .txt File
==========================================================

1. Make sure you have py-graspi installed: pip install py-graspi
2. Make sure you cd into the py-graspi directory first. From there, cd into the tools then translations by running 'cd tools/translations'.
3. The command line format to translate an image file into its truncated .txt file is as follows:

.. code-block:: bash

    python img_to_txt.py {pathname of image file} {Resize calculation amount}

4. The "resize calculation amount" is multiplied to the X and Y axis of the original image and this will alter the size of the image's final resized .txt file.
5. This should place both a truncated image file and truncated .txt file of the original image file into the "resized" directory.
6. They will be named "resized_" followed by the image file name and correct extension.
7. An example command line input that should work for this repo is as follows:

.. code-block:: bash

    python img_to_txt.py ../../data/images/data_0.5_2.2_001900.png 0.15

2D & 3D Morphologies Tests
========================================

To run the 2d and 3d morphologies you will need to setup notebook and pip install the graspi_igraph package.

First you will need to git clone the current repo:

.. code-block:: bash

    git clone https://github.com/owodolab/py-graspi.git

Then, you will need to install the igraph package:

.. code-block:: bash

    pip install py-graspi

Install jupyter notebook in order to view the test file:

.. code-block:: bash

    pip install notebook

Finally, you will be able to use the command:

.. code-block:: bash

    jupyter notebook

This will bring you into the testing filing on jupyter.

Navigate to the file **graspi_igraph_notebook.ipynb** under the **notebook** directory.

On this file you will be able to run and view the 2d and 3d morphologies.

Running All 33 Morphologies Tests
=========================================

To run the morphologies tests, first make sure you're on the **py-graspi** directory.
- Run the following command to start at the py-graspi directory:

.. code-block:: bash

    cd ..

- Next, make sure you're running using bash by running the following command:

.. code-block:: bash

    bash

- Next, run the following command:

.. code-block:: bash

    chmod +x run.sh

- Finally, run the following command for .txt or .pdf generation:

.. code-block:: bash

    ./run.sh <file_type>

Substitute `<file_type>` with either `txt` or `pdf` for the desired output type.

**Example:**

.. code-block:: bash

    ./run.sh txt

**Note: You should run `txt` before `pdf` to update text files and for an accurate PDF output**

33 Morphologies Output
==========================

After running the command, the automatic report generation will begin.
The following will print when the report generation begins:

.. code-block::

    Generating PDF (If on pdf mode)
    Generating Text Files

As the script is running, the following will print for which microstructure it is on

.. code-block::

Executing <test_file>

After a few minutes, the following will print once the report has been created

.. code-block::

    Text Files Generated
    PDF Generated (If on pdf mode)

**Viewing 33 Morphologies Output**

**For text files**, navigate to the results directory by using the following command:

.. code-block:: bash

    cd data/results

- Use the following command to view the list of text files generated:

.. code-block:: bash

    ls

- To view the result in each file, run the following command:

.. code-block:: bash

    cat <result_file_name>

- Replace `<result_file_name>` with any of the files outputted by running `ls`
Example:

.. code-block:: bash

    cat descriptors-data_0.514_2.4_000220.txt

**If using pdf mode**, the PDF should automattically open upon completion.
If the pdf does not automatically pop up, use the following commands, making sure you're on the `py-graspi` directory:

- On Windows

.. code-block:: bash

    start py_graspi/test_results.pdf

- On MacOS

.. code-block:: bash

    open py_graspi/test_results.pdf

- On Linux

.. code-block:: bash

    evince py_graspi/test_results.pdf

If evince is not installed, run this first:

.. code-block:: bash

    sudo apt install evince

Tortuosity HeatMap Visualization
=======================================

This are the steps for visualizing tortuosity via HeatMap.
1. Make sure you cd into the py-graspi directory, then into tools then tortousity. Run cd tools/tortousity to get there.
2. All necessary functions are in the tortuosity.py file.
3. Code necessary to visualize the tortuosity HeatMap is as follows:

.. code-block:: bash

    python tortuosity.py {pathname of file}

4. This code will only work if the IdTortuosityBlackToRed descriptors of this file
have been found and outputted to it's corresponding file in the distances directory.
5. For now there are some file examples in this directory so an example code
to visualize a heatmap is as follows:

.. code-block:: bash

    python tortuosity.py ../../data/data/data_0.5_2.2_001900.txt

6. First a tortuosity heatmap will output for Black To Red vertices.
7. Exit out of this pop up window.
8. Second a totuosity heatmap will output for White to Blue vertices.
9. Exit out of this pop up Window.

* A HeatMap should show up with a HeatMap Bar to the right of the HeatMap.
* Based on current implementation, this HeatMap outputs tort values of each vertex and that value is used to color in the Heatmap based on the HeatMap Bar.
* Read the side bar to the right to understand the cyclic gradiant coloring.
* Following is the matplotlib api section for more information on this gradiant: https://matplotlib.org/stable/users/explain/colors/colormaps.html#cyclic

Jupyter NoteBook to Visualize HeatMap
=========================================

1. Make sure Jupyter Notebook is installed:

.. code-block:: bash

    pip install jupyter

2. Run jupyter notebook with following command:

.. code-block:: bash

    jupyter notebook

3. Open up `tortuosity.ipynb` under the `py_graspi` directory.
4. Click the Run tab on the top.
5. Click "Run All Cells"
6. Wait a bit and the HeatMaps of some files will be created and visualized.

Mycelium Filtered Vertices Visualization
=========================================

This section explains how to visualize a mycelium image by both it's white and black vertices filtered versions.
The mycelium image used is included in the "images" directory called "mycelium.png".

The following are steps on how to visualize the graph from this image.
1. Make sure you have py-graspi installed: pip install py-graspi
2. Make sure you cd into py-graspi directory first.
3. The command line format input is as follows

.. code-block:: bash

    python myceliumTest.py {pathname of image file} {Resize calculation amount}

4. The input is the same as the translation input from image files to .txt files, it will create a new .img and .txt file for it in the "resized" directory.
5. The image input pathname must be in the "images" directory.
6. If you wish to not resize the original image just input a '1' for the Resize calculation amount, this will keep the original size.
7. Example command line input is as follows:

.. code-block:: bash

    python myceliumTest.py ../../data/images/data_0.5_2.2_001900.png 0.15

8. This creates a truncated version of the mycelium image (for runtime purposes) and outputs the largest subgraph of the following filtered graphs:
   1. The first one is a white only vertex graph
   2. The second one is a black only vertex graph.

Mycelium Filtered Vertices Interactivity
=========================================

1. Follow these steps to run through different interactive features after running the myceliumTest.py file
2. On the bottom left of the window, there will be some built-in mathplotlib tools in the following order: "Reset Home Button," "Undo," "Redo," "Drag and Pull Move Mode," "Zoom in Mode," "Configuration Settings," and "Save File."
3. The Reset Home Button, when clicked, will take you to the center of the graph no matter where you are. You may need to zoom out a couple of times, but if you do, you will resort back to the original graph visualization (not accounting for rotations).
4. We will not use these Redo/Undo buttons since they only work with the mathplotlib built-in functionalities and not my built-in ones so they may cause confusion.
5. The Drag and Pull Mode Button, when clicked, allows the user to hold a click on the graph and move around as desired. Make sure you are able to move around easily.
6. The Zoom In Mode will make it so you can crop out a rectangular area and it will automatically zoom into this area. This is helpful for easier massive zooms and can be used with the built-in zoom in/out buttons. Make sure you can zoom in with this functionality.
7. The Configuration Settings will open up a window with sliders. These sliders will change the border of the graph and get rid of white space around the graph. Play with the sliders to make sure you are able to change the border fo the graph visualization. (The bottom two sliders do not affect our graph visualization in any way, recommend not to mess with these).
8. If you wish to reset the configurations there is a "reset" button on the bottom right of this new pop up window, click this and confirm that all the settings are back to how they were originally.
9. The Save File button works just as any other save file button. This allows to save the graph visualization into your computer files.
10. There are also 4 buttons to the bottom right of the Graph in the following order: Zoom In, Zoom Out, Rotate CW, and Rotate CCW.
11. Pressing the Zoom In button which will zoom into the graph.
12. Pressing the Zoom Out button will zoom out the same amount as it zoomed in.
13. Pressing Rotate CW will rotate the graph by 30 degrees clockwise.
14. Pressing Rotate CCW will rotate the graph by 30 degrees counter-clockwise.

Generate and Run Files for Py-Graspi API Documentation
==================

In order to generate an API using sphinx, you need to follow the installation of py-graspi:

Install ghp-import in the project root directory:

.. code-block:: bash

   pip install ghp-import

To generate the rst files into the local html, run this command:

.. code-block:: bash

   sphinx-build -b html docs/source docs/build

Ensure that the files have been generated in docs/build.

To push the changes reflected on the html to the gh-pages branch on GitHub, essentially pushing changes to the site, run this command:

.. code-block:: bash

   ghp-import -n -p -f docs/build/

Go to the GitHub repo and verify that the files were pushed to the gh-pages branch

Access and verify the documentation through the following URL: https://owodolab.github.io/py-graspi/.

Update Py-Pi Package
====================

If there are changes made to the to the PyGraspi package locally, these instructions can help push to Py-Pi.

1. To install setuptools, wheel and twine, run this command in terminal:

.. code-block:: bash

   pip install setuptools wheel twine

Ensure that the project already contains setup.py, README.md, _init_.py, LICENSE and other core files.

If the current package was never pushed to PyPI, continue to step 2. If the package has already been pushed before, make sure you update the version number in the setup.py file.

2. Build the distribution files, which creates a dist/ directory containing the .tar.gz and .whl files.

First, CD into project root directory. Then, run this command in terminal:

.. code-block:: bash

   python setup.py sdist bdist_wheel

(Optional) It's safe to delete the .tar.gz and .whl file of old versions so that the correct version gets pushed to PyPI

3. Login to PyPI, and in settings

4. Use twine to upload the distribution securely by running this command in terminal:

.. code-block:: bash

   twine upload dist/*

When prompted for your API token, retrieve the API token that you can generate from PyPI. The token will not be visible on the terminal, so press enter after entering the token.

Verify that the new version has been uploaded successfully at the link https://pypi.org/project/py-graspi/